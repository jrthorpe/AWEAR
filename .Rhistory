setwd("M:/PhD_Folder/CaseStudies/Data_analysis/source")
# Load required packages:
# (Note: had trouble installing packages which I resolved by using .libpaths() to find where packages are installed and manually moving the packages from wherever R temporarily installed them to there)
library(data.table)
library(dtplyr)
library(dplyr)
library(magrittr)
library(lubridate)
library(ggplot2)
library(reshape2)
library(maptools)
library(plotly)
library(maps)
library(mapproj)
library(sp)
library(caTools)
library(geosphere) # added in v3
# Load custom functions:
source("JRT_utils.R")
# Define constants:
folder <- "../Data_dumps/dump_current_analysis/" # path to folder that holds multiple .csv files, downloaded from nightingale webportal
not.in.use <- c("bluetooth","hardware_info","wearable","wifi")
activity.selection <- c("Still", "Foot", "Vehicle", "Tilting", "Bicycle") # main activity types
to_plot <- c("activity",
"battery",
"exps",
"location",
"screen",
"steps")
users <- list(julia = "93a6d31c-e216-48d8-a9a2-f2f72362548d",
dean = "b1316280-38a6-45e1-9bb9-7afb2a1a2a96",
per = "7bf5fec3-f46f-419e-9573-001fe9b47d81",
P01FA = "6321f7ef-a958-44ad-b8e5-5aa04bc004e1",
P03JJ = "e9f44eb5-8962-4894-83c6-783025c6eaea")
# SETTINGS -------------------------------------------------------------------------------------------
# Select user and period of interest:
# Test users:
userid <- users$julia
d.start <- as.POSIXct("2018-02-01") # yyyy-mm-dd
d.stop <- as.POSIXct("2018-03-30")
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
datasets.all <- Filter(function(x) !is.null(x)[1],datasets.all) # remove any null dataframes
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
folder <- "../../Data_dumps/dump_current_analysis/" # path to folder that holds multiple .csv files, downloaded from nightingale webportal
not.in.use <- c("bluetooth","hardware_info","wearable","wifi")
activity.selection <- c("Still", "Foot", "Vehicle", "Tilting", "Bicycle") # main activity types
to_plot <- c("activity",
"battery",
"exps",
"location",
"screen",
"steps")
users <- list(julia = "93a6d31c-e216-48d8-a9a2-f2f72362548d",
dean = "b1316280-38a6-45e1-9bb9-7afb2a1a2a96",
per = "7bf5fec3-f46f-419e-9573-001fe9b47d81",
P01FA = "6321f7ef-a958-44ad-b8e5-5aa04bc004e1",
P03JJ = "e9f44eb5-8962-4894-83c6-783025c6eaea")
userid <- users$julia
d.start <- as.POSIXct("2018-02-01") # yyyy-mm-dd
d.stop <- as.POSIXct("2018-03-30")
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
location<-datasets.all$location
xy <- select(location, lat, lon)
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data"
#color = ~dsource
)
d.stop <- as.POSIXct("2018-03-16")
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
datasets.all <- Filter(function(x) !is.null(x)[1],datasets.all) # remove any null dataframes
location<-datasets.all$location
xy <- select(location, lat, lon)
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data"
#color = ~dsource
)
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)
centroid <- apply(xy,2,mean)
distances <- sqrt(((xy[, 1] - centroid[1])^2) + ((xy[, 2] - centroid[2])^2))
# get subset of points within specified quantile of distances
indx <- 1:length(distances)
percentages <- indx[distances <= quantile(distances, .99)]
xy.subset <- xy[percentages, ]
# get minimum convex polygon
mcp.points <- chull(xy.subset[, 1], xy.subset[, 2]) # index of points that lie on mcp
mcp <- xy.subset[mcp.points,] # coords of mcp
mcp <- rbind(mcp[nrow(mcp), ], mcp) # repeat last point to close shape
mcp.poly<-Polygon(mcp) # creates a polygon object with area attribute (access uing @area)
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)%>%
add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lat, y=~mcp$lon, mode = "lines", name = 'mcp')
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)
%>%
#add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lat, y=~mcp$lon, mode = "lines", name = 'mcp')
# calculate distances from all points to centroid of the location data
xy <- select(location, lat, lon)
centroid <- apply(xy,2,mean)
distances <- sqrt(((xy[, 1] - centroid[1])^2) + ((xy[, 2] - centroid[2])^2))
# get subset of points within specified quantile of distances
indx <- 1:length(distances)
percentages <- indx[distances <= quantile(distances, .99)]
xy.subset <- xy[percentages, ]
# get minimum convex polygon
mcp.points <- chull(xy.subset[, 1], xy.subset[, 2]) # index of points that lie on mcp
mcp <- xy.subset[mcp.points,] # coords of mcp
mcp <- rbind(mcp[nrow(mcp), ], mcp) # repeat last point to close shape
mcp.poly<-Polygon(mcp) # creates a polygon object with area attribute (access uing @area)
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)%>%
#add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lat, y=~mcp$lon, mode = "lines", name = 'mcp')
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)%>%
#add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lon, y=~mcp$lat, mode = "lines", name = 'mcp')
# calculate distances from all points to centroid of the location data
xy <- select(location, lat, lon)
centroid <- apply(xy,2,mean)
distances <- sqrt(((xy[, 1] - centroid[1])^2) + ((xy[, 2] - centroid[2])^2))
# get subset of points within specified quantile of distances
indx <- 1:length(distances)
percentages <- indx[distances <= quantile(distances, .999)]
xy.subset <- xy[percentages, ]
# get minimum convex polygon
mcp.points <- chull(xy.subset[, 1], xy.subset[, 2]) # index of points that lie on mcp
mcp <- xy.subset[mcp.points,] # coords of mcp
mcp <- rbind(mcp[nrow(mcp), ], mcp) # repeat last point to close shape
mcp.poly<-Polygon(mcp) # creates a polygon object with area attribute (access uing @area)
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)%>%
#add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lon, y=~mcp$lat, mode = "lines", name = 'mcp')
rxy<-xy[sample(nrow(xy), 30000), ]
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)%>%
#add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lon, y=~mcp$lat, mode = "lines", name = 'mcp') %>%
add_trace(x=~rxy$lon, y=~rxy$lat, mode = "markers", marker = list(size = 2), color="green")
rxy<-xy[sample(nrow(xy), 1000), ]
plot_ly(xy,
x=~lon,
y=~lat,
type="scatter",
mode = "markers",
name = "location data",
marker = list(size = 2)
#color = ~dsource
)%>%
#add_trace(x=~centroid[1], y=~centroid[2], mode = "markers", marker = list(size = 10), name = 'centroid') %>%
add_trace(x=~mcp$lon, y=~mcp$lat, mode = "lines", name = 'mcp') %>%
add_trace(x=~rxy$lon, y=~rxy$lat, mode = "markers", marker = list(size = 2))
