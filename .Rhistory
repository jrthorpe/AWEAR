points <- gps.log %>%
filter(timestamp>=timestamp[i], timestamp<=timestamp[i]+deltaT*60) %>%
select(lat, lon)
# diagonal distance across bounding box enclosing the selected point
bob <- data.frame(bbox(SpatialPoints(points)))
distances[i] <- distGeo(bob$min, bob$max, a=6378137, f=1/298.257223563)
}
remove(bob,points,i)
# Append distances and assign "stays" if below threshold deltaD
gps.traj <- cbind(gps.log,distances) %>%
mutate(stays=(distances<deltaD)*1) %>%
mutate(staygo_group=cumsum(c(0,abs(diff(stays))))+1)
# calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(stays==1) %>%
group_by(staygo_group) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
dist_threshold <- 25 #
p1<-rev(home) # reverses elements to get lat and lon in correct order
p2<-stay.centroids[,c("c.lon","c.lat")]
stay.centroids %<>% mutate(dist2home=distGeo(p1, p2, a=6378137, f=1/298.257223563)) %>% # create "home" group column (TRUE/FALSE) in stay.info summary
mutate(is.home=dist2home<dist_threshold) %>%
mutate(c.lon = ifelse(is.home, home[1],c.lon), # assign "home" coordinates to any points close to home
c.lat = ifelse(is.home, home[2],c.lat))
View(stay.centroids)
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list()
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist.threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list()
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-12"), timestamp<=as.POSIXct("2018-02-13")) # reduce to single day
gps.log.pre <- datasets.all$location %>% filter(accuracy<=50)
keep.ratio <- nrow(gps.log.pre)/nrow(datasets.all$location)
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-12"), timestamp<=as.POSIXct("2018-02-13")) # reduce to single day
#remove(datasets.all)
# Calculate home coordinates based on location data
home <- findhome(gps.log,"lat","lon")
# Stay detection algorithm (to be moved into a function) ------
# Initial identification of stays:
deltaT <- 10  #time threshold in minutes
deltaD <- 100 #distance threshold in meters
distances <- NULL #TODO find out best way to append data to vector in for loop
# For all points, gets the distance across the area covered in the following deltaT minutes
for (i in 1:nrow(gps.log)){
# get all GPS data points in a timeframe of deltaT
points <- gps.log %>%
filter(timestamp>=timestamp[i], timestamp<=timestamp[i]+deltaT*60) %>%
select(lat, lon)
# diagonal distance across bounding box enclosing the selected point
bob <- data.frame(bbox(SpatialPoints(points)))
distances[i] <- distGeo(bob$min, bob$max, a=6378137, f=1/298.257223563)
}
remove(bob,points,i)
# Append distances and assign "stays" if below threshold deltaD
gps.traj <- cbind(gps.log,distances) %>%
mutate(stays=(distances<deltaD)*1) %>%
mutate(staygo_group=cumsum(c(0,abs(diff(stays))))+1)
# calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(stays==1) %>%
group_by(staygo_group) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
View(stay.centroids)
#home_threshold <- 16 # in meters; think this was based on how far away 2 places could be within same 4 decimals level of GPS info used for home calculation
dist_threshold <- 25 #
p1<-rev(home) # reverses elements to get lat and lon in correct order
p2<-stay.centroids[,c("c.lon","c.lat")]
stay.centroids %<>% mutate(dist2home=distGeo(p1, p2, a=6378137, f=1/298.257223563)) %>% # create "home" group column (TRUE/FALSE) in stay.info summary
mutate(is.home=dist2home<dist_threshold) %>%
mutate(c.lon = ifelse(is.home, home[1],c.lon), # assign "home" coordinates to any points close to home
c.lat = ifelse(is.home, home[2],c.lat))
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list()
View(centroids.pool)
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
plot_ly(gps.traj,
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group)
mappoints <- gps.traj
coordinates(mappoints) <- ~ lon + lat
proj4string(mappoints) <- "+init=epsg:4326"
mapview(mappoints, zcol = "staygo_group", burst = TRUE, map.types = "OpenStreetMap")
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-13"), timestamp<=as.POSIXct("2018-02-14")) # reduce to single day
#remove(datasets.all)
# Calculate home coordinates based on location data
home <- findhome(gps.log,"lat","lon")
# Stay detection algorithm (to be moved into a function) ------
# Initial identification of stays:
deltaT <- 10  #time threshold in minutes
deltaD <- 100 #distance threshold in meters
distances <- NULL #TODO find out best way to append data to vector in for loop
# For all points, gets the distance across the area covered in the following deltaT minutes
for (i in 1:nrow(gps.log)){
# get all GPS data points in a timeframe of deltaT
points <- gps.log %>%
filter(timestamp>=timestamp[i], timestamp<=timestamp[i]+deltaT*60) %>%
select(lat, lon)
# diagonal distance across bounding box enclosing the selected point
bob <- data.frame(bbox(SpatialPoints(points)))
distances[i] <- distGeo(bob$min, bob$max, a=6378137, f=1/298.257223563)
}
remove(bob,points,i)
# Append distances and assign "stays" if below threshold deltaD
gps.traj <- cbind(gps.log,distances) %>%
mutate(stays=(distances<deltaD)*1) %>%
mutate(staygo_group=cumsum(c(0,abs(diff(stays))))+1)
# calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(stays==1) %>%
group_by(staygo_group) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
# convert any stays that are home to home centroid
#home_threshold <- 16 # in meters; think this was based on how far away 2 places could be within same 4 decimals level of GPS info used for home calculation
dist_threshold <- 25 #
p1<-rev(home) # reverses elements to get lat and lon in correct order
p2<-stay.centroids[,c("c.lon","c.lat")]
stay.centroids %<>% mutate(dist2home=distGeo(p1, p2, a=6378137, f=1/298.257223563)) %>% # create "home" group column (TRUE/FALSE) in stay.info summary
mutate(is.home=dist2home<dist_threshold) %>%
mutate(c.lon = ifelse(is.home, home[1],c.lon), # assign "home" coordinates to any points close to home
c.lat = ifelse(is.home, home[2],c.lat))
View(stay.centroids)
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list()
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
View(centroids.pool)
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
View(merges)
merges[1]
merges[[1]]
c(1,2,3,17) %in% merges
c(1,2,3,17) %in% merges[1]
c(1,2,3,17) %in% merges[[1]]
paste0("staygo_group",centroids.pool$staygo_group[1])
c(1,2,3,17) %in% merges$staygo_group17
c(1,2,3,17) %in% merges$staygo_group17[1]
c(1,2,3,17) %in% merges$staygo_group17[[1]]
c(1,2,3,17) %in% merges[[[1]]]
c(1,2,3,17) %in% merges$staygo_group17[[1]]
merges=list()
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list()
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
merges <- c(merges, filter(centroids.pool,is.close)) %>%
select(staygo_group)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list(apple="a")
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges=list()
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
merges[1]
merges[[1]]
merge.set <- filter(centroids.pool,!is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
is.close
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
merge.set <- filter(centroids.pool[1:2,],is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
str(merge.set)
as.numeric(merge.set)
as.vector(merge.set)
# create a "stay ID" column to be distinct from a stay event
for (m in merges){
c(1,2,17,3,4,5,6,7,8,9,12,11,12) %in% m
}
for (m in merges){
print(c(1,2,17,3,4,5,6,7,8,9,12,11,12) %in% m)
}
for (m in merges){
print(c(1,2,21,3,4,5,6,7,8,9,12,11,12) %in% m)
}
gps.traj  %<>% mutate(stay.id = staygo_group)
for (m in merges){
#print(c(1,2,21,3,4,5,6,7,8,9,12,11,12) %in% m)
gps.traj  %<>% mutate(stay.id = ifelse(staygo_group %in% m,m[1],stay.id) )
}
distinct(gps.traj$stay.id)
distinct(gps.traj,stay.id)
View(centroids.pool)
staygo_group(is.home)
stay.centroids$staygo_group[is.home]
View(stay.centroids)
filter(stay.centroids, is.home)$staygo_group
merges<-list(home=filter(stay.centroids, is.home)$staygo_group)
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
View(gps.traj)
gps.traj  %<>% mutate(stay.id = staygo_group)
for (m in merges){
#print(c(1,2,21,3,4,5,6,7,8,9,12,11,12) %in% m)
gps.traj  %<>% mutate(stay.id = ifelse(staygo_group %in% m,m[1],stay.id) )
}
distinct(gps.traj,stay.id)
# create a "stay ID" column to be distinct from a stay event
gps.traj  %<>% mutate(stay.id = staygo_group) %<>%
home.set <- stay.centroids %>% filter(is.home)  %>% select(staygo_group)
home.set <- stay.centroids %>% filter(is.home)  %>% select(staygo_group)
View(home.set)
gps.traj  %<>% mutate(stay.id = ifelse(staygo_group %in% home.set,"home",staygo_group))
c(1,2,3) %in% home.set
c(1,2,3) %in% home.set[,]
c(1,2,3) %in% home.set[,1]
c(1,2,3) %in% home.set[[,1]]
c(1,2,3) %in% home.set$staygo_group
gps.traj  %<>% mutate(stay.id = ifelse(staygo_group %in% home.set$staygo_group,"home",staygo_group))
m
paste0("S",m[1])
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges<-list()
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("staygo_group",centroids.pool$staygo_group[1])]] <- filter(centroids.pool,is.close) %>%
merge.set <- filter(centroids.pool,is.close) %>%
select(staygo_group)
merges <- c(merges, merge.set)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
# NEXT STEPS:
# recalculate centroids by merging data in any close stays
# create a "stay ID" column to be distinct from a stay event
home.set <- stay.centroids %>% filter(is.home)  %>% select(staygo_group)
gps.traj  %<>% mutate(stay.id = ifelse(staygo_group %in% home.set$staygo_group,"home",staygo_group))
for (m in merges){
#print(c(1,2,21,3,4,5,6,7,8,9,12,11,12) %in% m)
gps.traj  %<>% mutate(stay.id = ifelse(staygo_group %in% m,paste0("S",m[1]),stay.id) )
}
distinct(gps.traj,stay.id)
# calculate centroids of all stay id's
stay.centroids.updated <- gps.traj %>% filter(stays==1) %>%
group_by(stay.id) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
View(stay.centroids.updated)
test <- c(1,2,3,4)
test > 2
testt <- ifelse(test>2,4,0)
testt
2<test
ifany(test<2,1,0)
any(test<2)
distGeo(gps.traj[c("lon",lat"),1], select(stay.centroids.updated,c.lon,c.lat), a=6378137, f=1/298.257223563)
)
gps.traj[c("lon",lat"),1]
gps.traj[1,c("lon",lat")]
gps.traj[c("lon",lat")][1,]
gps.traj[1,]
gps.traj[1,"lon"]
gps.traj[1,"lon","lat"]
gps.traj[1,c("lon","lat")]
gps.traj[1,c("lon","lat")]
distGeo(gps.traj[1,c("lon","lat")], select(stay.centroids.updated,c.lon,c.lat), a=6378137, f=1/298.257223563)
distGeo(gps.traj[,c("lon","lat")], select(stay.centroids.updated,c.lon,c.lat), a=6378137, f=1/298.257223563)
# classify all points within 30m of any centroids as a stay
gps.traj  %<>% mutate(distances = distGeo(gps.traj[,c("lon","lat")],
select(stay.centroids.updated,c.lon,c.lat),
a=6378137, f=1/298.257223563))
View(gps.traj)
test <- distGeo(gps.traj[,c("lon","lat")],
select(stay.centroids.updated,c.lon,c.lat),
a=6378137, f=1/298.257223563)
View(gps.traj)
# classify all points within 30m of any centroids as a stay
gps.traj %<>% mutate(stays.updated=0)
select(stay.centroids.updated,c.lon,c.lat)
i<-1
gps.traj[i,c("lon","lat")]
centroid.positions
centroid.positions <- select(stay.centroids.updated,c.lon,c.lat)
dists <- distGeo(gps.traj[i,c("lon","lat")],
centroid.positions,
a=6378137, f=1/298.257223563)
centroid.positions
dists
gps.traj %<>% mutate(stays.updated=0)
centroid.positions <- select(stay.centroids.updated,c.lon,c.lat)
for (i in 1:nrow(gps.traj)){
dists <- distGeo(gps.traj[i,c("lon","lat")],
centroid.positions,
a=6378137, f=1/298.257223563)
gps.traj$stays.updated[i] <- any(dists<dist_threshold)
}
gps.traj <- mutate(staygo_group.updated=cumsum(c(0,abs(diff(stays.updated))))+1)
stay.centroids.updated <- gps.traj %>% filter(stays==1) %>%
group_by(stay.id) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
# classify all points within 30m of any centroids as a stay
gps.traj %<>% mutate(stays.updated=0)
centroid.positions <- select(stay.centroids.updated,c.lon,c.lat)
for (i in 1:nrow(gps.traj)){
dists <- distGeo(gps.traj[i,c("lon","lat")],
centroid.positions,
a=6378137, f=1/298.257223563)
gps.traj$stays.updated[i] <- any(dists<dist_threshold)
}
gps.traj <- mutate(staygo_group.updated=cumsum(c(0,abs(diff(stays.updated))))+1)
gps.traj %<>% mutate(staygo_group.updated=cumsum(c(0,abs(diff(stays.updated))))+1)
plot_ly(gps.traj,
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group.updated)
distinct(gps.traj,staygo_group.updated)
plot_ly(gps.traj[stays.updated,],
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group.updated)
plot_ly(gps.traj[gps.trajstays.updated,],
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group.updated)
plot_ly(gps.traj[gps.traj$stays.updated,],
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group.updated)
plot_ly(gps.traj[gps.traj$stays.updated==1,],
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group.updated)
plot_ly(gps.traj[gps.traj$stays.updated==0,],
x=~lon,
y=~lat,
type = "scatter",
mode = "markers",
color = ~staygo_group.updated)
