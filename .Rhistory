# Preprocessing steps
gps.log.pre <- datasets.all$location %>% filter(accuracy<=50) # get rid of data points with an "accuracy" above 50m
keep.ratio <- nrow(gps.log.pre)/nrow(datasets.all$location)
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals.alt, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-13"), timestamp<=as.POSIXct("2018-02-14")) # reduce to single day
# Calculate home coordinates based on location data
home <- findhome(gps.log,"lat","lon")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
deltaT <- 10  # time threshold in minutes
deltaD <- 100 # distance threshold in meters
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
dT <- 10  # delta T, time window in minutes
dD <- 100 # delta D, distance threshold in meters
is.stay <- get_stays(gps.log, dT, dD)
is.stay <- get_stays(gps.log, deltaT=dT, deltaD=dD)
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
is.stay <- get_stays(gps.log, dT, dD)
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
gps.traj <- get_stays(gps.log, dT, dD)
View(gps.traj)
remove(deltaD,deltaT,is.stay)
# define variables:
dist_threshold <- 30 # distance in meters within which two centriods belong to same stay location
# identify any stays that are "home" based on proximity to home centroid
stay.centroids %<>%
mutate(dist2home=distGeo(rev(home),
stay.centroids[,c("c.lon","c.lat")],
a=6378137, f=1/298.257223563)) %>%
mutate(is.home=dist2home<dist_threshold)
# merge any other close centroids
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
# Summarise stay and go events
event.summary <- gps.traj %>% group_by(event.id) %>%
summarize(T.start = min(timestamp), is.stay = max(is.stay)) %>%
mutate(T.end = c(T.start[-1],max(gps.traj$timestamp))) %>%
mutate(durations = difftime(T.end,T.start, units = "mins"))
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
# define variables:
dist_threshold <- 30 # distance in meters within which two centriods belong to same stay location
# identify any stays that are "home" based on proximity to home centroid
stay.centroids %<>%
mutate(dist2home=distGeo(rev(home),
stay.centroids[,c("c.lon","c.lat")],
a=6378137, f=1/298.257223563)) %>%
mutate(is.home=dist2home<dist_threshold)
# merge any other close centroids
centroids.pool <- filter(stay.centroids,is.home==FALSE) # get all non-home stay centroids
merges<-list()
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("event.id",centroids.pool$event.id[1])]] <- filter(centroids.pool,is.close) %>%
merge.set <- filter(centroids.pool,is.close) %>%
select(event.id)
merges <- c(merges, group=merge.set)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
View(merges)
centroids.pool <- stay.centroids
merges<-list()
centroids.pool <- stay.centroids
centroids.pool <- stay.centroids
while (nrow(centroids.pool)>1) {
# select first point in the set and calculate distances to all others
tmp <- select(centroids.pool[1,],c.lon,c.lat)
distances <- distGeo(tmp, select(centroids.pool,c.lon,c.lat), a=6378137, f=1/298.257223563)
# test distances against threshold
is.close <- distances<dist_threshold
# store group numbers of any close stay events
if (sum(is.close)>1){
#merges[[paste0("event.id",centroids.pool$event.id[1])]] <- filter(centroids.pool,is.close) %>%
merge.set <- filter(centroids.pool,is.close) %>%
select(event.id)
merges <- c(merges, group=merge.set)
}
# remove current centroid and any that are merged
centroids.pool %<>% filter(!is.close)  #(note: the current centroid is filtered out as it is close to itself)
}
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(c.lat = mean(lat, na.rm=TRUE), c.lon = mean(lon, na.rm = TRUE))
# define variables:
dist_threshold <- 30 # distance in meters within which two centriods belong to same stay location
# identify any stays that are "home" based on proximity to home centroid
stay.centroids %<>%
mutate(dist2home=distGeo(rev(home),
stay.centroids[,c("c.lon","c.lat")],
a=6378137, f=1/298.257223563)) %>%
mutate(is.home=dist2home<dist_threshold)
View(stay.centroids)
sum(stay.centroids$is.home)
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(lat = mean(lat, na.rm=TRUE), lon = mean(lon, na.rm = TRUE))
warnings()
gps.traj <- get_stays(gps.log, dT, dD)
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(lat = mean(lat, na.rm=TRUE), lon = mean(lon, na.rm = TRUE))
# AWEAR: BEHAVIOURAL ANALYSIS FRAMEWORK
#
#********************************************************************************************
# Author: Julia Thorpe
# Written for AWEAR Case Studies, January-June 2018, as part of an ongoing PhD
# project on Engineering Systems Design in Healthcare at DTU in collaboration
# with Rigshospitalet-Glostrup
# This script ...
# SETUP -------------------------------------------------------------------------------------------
# Set the drive, load packages and functions.
#setwd("M:/PhD_Folder/CaseStudies/Data_analysis/source")
## For mobility pack (downloaded from Git) -- maybe don't need these anymore?
#library(DataCombine)
#library(zoo)
#library(plyr)
library(data.table)
library(dtplyr)
library(dplyr)
library(magrittr)
library(lubridate)
library(ggplot2)
library(reshape2)
library(maptools)
library(plotly)
library(maps)
library(mapproj)
library(sp)
library(caTools)
library(geosphere) # added in v3 of data checker
library(mapview) # added in v1 of analysis framework
# Load custom functions:
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/JRT_utils.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
# Define constants:
folder <- "M:/PhD_Folder/CaseStudies/Data_dumps/dump_current_analysis/" # path to folder that holds multiple .csv files, downloaded from nightingale webportal
not.in.use <- c("bluetooth","hardware_info","wearable","wifi","calllog","sms")
to_plot <- c("activity", # from data checker, for debugging purposes only (visualise all datasets)
"battery",
"exps",
"location",
"screen",
"steps")
users <- list(julia = "93a6d31c-e216-48d8-a9a2-f2f72362548d",
dean = "b1316280-38a6-45e1-9bb9-7afb2a1a2a96",
per = "7bf5fec3-f46f-419e-9573-001fe9b47d81",
P01FA = "6321f7ef-a958-44ad-b8e5-5aa04bc004e1",
P03JJ = "e9f44eb5-8962-4894-83c6-783025c6eaea")
# SETTINGS -------------------------------------------------------------------------------------------
# Select user and period of interest:
# Test users:
userid <- users$julia
# set the period of interest
d.start <- as.POSIXct("2018-02-05") # yyyy-mm-dd
d.stop <- as.POSIXct("2018-02-19")
# IMPORT AND RESTRUCTURE DATA -------------------------------------------------------------------------------------------
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
datasets.all <- Filter(function(x) !is.null(x)[1],datasets.all) # remove any null dataframes
remove(d.start, d.stop, folder, not.in.use, userid, users)
# Preprocessing steps
gps.log.pre <- datasets.all$location %>% filter(accuracy<=50) # get rid of data points with an "accuracy" above 50m
keep.ratio <- nrow(gps.log.pre)/nrow(datasets.all$location)
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals.alt, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-13"), timestamp<=as.POSIXct("2018-02-14")) # reduce to single day
# Calculate home coordinates based on location data
home <- find_home(gps.log,"lat","lon")
# Define variables:
dT <- 10  # delta T, time window in minutes
dD <- 100 # delta D, distance threshold in meters
gps.traj <- get_stays(gps.log, dT, dD)
# Summarise stay and go events
event.summary <- gps.traj %>% group_by(event.id) %>%
summarize(T.start = min(timestamp), is.stay = max(is.stay)) %>%
mutate(T.end = c(T.start[-1],max(gps.traj$timestamp))) %>%
mutate(durations = difftime(T.end,T.start, units = "mins"))
# define variables:
dist.threshold <- 30 # distance in meters within which two centriods belong to same stay location
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(lat = mean(lat, na.rm=TRUE), lon = mean(lon, na.rm = TRUE))
View(stay.centroids)
merge_spatial(stay.centroids,dist.threshold)
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
merge_spatial(stay.centroids,dist.threshold)
?setNames
setNames(merges,c("test1","test2"))
merges<-merge_spatial(stay.centroids,dist.threshold)
setNames(merges,c("test1","test2"))
length(merges)
paste0("element", 1:3)
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
mergeee <- merge_spatial(stay.centroids,dist.threshold)
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(lat = mean(lat, na.rm=TRUE), lon = mean(lon, na.rm = TRUE))
mergeee <- merge_spatial(stay.centroids,dist.threshold)
N <- length(mergeee)
setNames(mergeee,paste0("merge", 1:N))
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
mergeee <- merge_spatial(stay.centroids,dist.threshold)
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
merg <- merge_spatial(stay.centroids,dist.threshold)
setNames(merges,paste0("test",1:2))
setNames(merges,paste0("merge", 1:N))
merges <- setNames(merges,paste0("merge", 1:N))
# AWEAR: BEHAVIOURAL ANALYSIS FRAMEWORK
#
#********************************************************************************************
# Author: Julia Thorpe
# Written for AWEAR Case Studies, January-June 2018, as part of an ongoing PhD
# project on Engineering Systems Design in Healthcare at DTU in collaboration
# with Rigshospitalet-Glostrup
# This script ...
# SETUP -------------------------------------------------------------------------------------------
# Set the drive, load packages and functions.
#setwd("M:/PhD_Folder/CaseStudies/Data_analysis/source")
## For mobility pack (downloaded from Git) -- maybe don't need these anymore?
#library(DataCombine)
#library(zoo)
#library(plyr)
library(data.table)
library(dtplyr)
library(dplyr)
library(magrittr)
library(lubridate)
library(ggplot2)
library(reshape2)
library(maptools)
library(plotly)
library(maps)
library(mapproj)
library(sp)
library(caTools)
library(geosphere) # added in v3 of data checker
library(mapview) # added in v1 of analysis framework
# Load custom functions:
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/JRT_utils.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
# Define constants:
folder <- "M:/PhD_Folder/CaseStudies/Data_dumps/dump_current_analysis/" # path to folder that holds multiple .csv files, downloaded from nightingale webportal
not.in.use <- c("bluetooth","hardware_info","wearable","wifi","calllog","sms")
to_plot <- c("activity", # from data checker, for debugging purposes only (visualise all datasets)
"battery",
"exps",
"location",
"screen",
"steps")
users <- list(julia = "93a6d31c-e216-48d8-a9a2-f2f72362548d",
dean = "b1316280-38a6-45e1-9bb9-7afb2a1a2a96",
per = "7bf5fec3-f46f-419e-9573-001fe9b47d81",
P01FA = "6321f7ef-a958-44ad-b8e5-5aa04bc004e1",
P03JJ = "e9f44eb5-8962-4894-83c6-783025c6eaea")
# SETTINGS -------------------------------------------------------------------------------------------
# Select user and period of interest:
# Test users:
userid <- users$julia
# set the period of interest
d.start <- as.POSIXct("2018-02-05") # yyyy-mm-dd
d.stop <- as.POSIXct("2018-02-19")
# IMPORT AND RESTRUCTURE DATA -------------------------------------------------------------------------------------------
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
datasets.all <- Filter(function(x) !is.null(x)[1],datasets.all) # remove any null dataframes
remove(d.start, d.stop, folder, not.in.use, userid, users)
# VISUALISE DATA-------------------------------------------------------------------------------------------
#show_plots(datasets.all, to_plot)
# MOBILITY -------------------------------------------------------------------------------------
# References: see files downloaded from GitHub. These use time and distance
# between points against thresholds to assign points to "stay events", based on
# work in an article by Zheng.
# -For each day:
#  .. Number of trips/stays
#  .. Time spent out of / at home
#  .. Distance covered in trajectories
#  .. Plot the day: over time, plot a bar with "home", "transit", "location A", "location B" etc
#  .. Work out how to annotate with the logbooks
# Moblity Setup: create datasets and variables required for mobility calculations -------
# Preprocessing steps
gps.log.pre <- datasets.all$location %>% filter(accuracy<=50) # get rid of data points with an "accuracy" above 50m
keep.ratio <- nrow(gps.log.pre)/nrow(datasets.all$location)
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals.alt, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-13"), timestamp<=as.POSIXct("2018-02-14")) # reduce to single day
# Calculate home coordinates based on location data
home <- find_home(gps.log,"lat","lon")
# STAY DETECTION (to be moved into separate function) ====
##* Initial identification of stays -----
# Define variables:
dT <- 10  # delta T, time window in minutes
dD <- 100 # delta D, distance threshold in meters
gps.traj <- get_stays(gps.log, dT, dD)
# Summarise stay and go events
event.summary <- gps.traj %>% group_by(event.id) %>%
summarize(T.start = min(timestamp), is.stay = max(is.stay)) %>%
mutate(T.end = c(T.start[-1],max(gps.traj$timestamp))) %>%
mutate(durations = difftime(T.end,T.start, units = "mins"))
## ________________________________________
# define variables:
dist.threshold <- 30 # distance in meters within which two centriods belong to same stay location
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(lat = mean(lat, na.rm=TRUE), lon = mean(lon, na.rm = TRUE))
merges <- merge_spatial(stay.centroids,dist.threshold)
View(event.summary)
event.summary %<>% mutate(stay.id = NA)
event.summary[c(1,2,4),"durations"]
event.summary[c(1,2,4),durations]
for (m in merges){
event.summary[event.id %in% m,"stay.id"] <- m[1]
}
event.summary[(event.summary$event.id %in% m),"stay.id"] <- m[1]
View(event.summary)
event.summary %<>% mutate(stay.id = NA)
for (m in merges){
browser()
event.summary[(event.summary$event.id %in% m),"stay.id"] <- m[1]
}
m
event.summary %<>% mutate(stay.id = NA)
for (m in merges){
print(m)
event.summary[(event.summary$event.id %in% m),"stay.id"] <- m[1]
}
event.summary %<>% mutate(stay.id = NA)
for (m in merges){
print(m)
event.summary[(event.summary$event.id %in% m),"stay.id"] <- m[[1]]
}
View(event.summary)
event.summary %<>% mutate(stay.id = ifelse(is.stay,event.id,NA)
)
for (m in merges){
print(m)
event.summary[(event.summary$event.id %in% m),"stay.id"] <- m[[1]]
}
View(event.summary)
distinct(event.summary$stay.id)
distinct(event.summary,stay.id)
tally(event.summary,is.stay)
tally(event.summary,!is.stay)
View(stay.centroids)
View(stay.centroids)
time.threshold <- 5 # in minutes
# Get all "go" events below time threshold
cond1 <- filter(event.summary,!is.stay,durations<=5) %>%
select(event.id)
# Get the id's of stays before and after each of the short "go" events
stay.before <- filter(event.summary,event.id %in% (cond1$event.id-1)) %>% select(stay.id)
stay.after <- filter(event.summary,event.id %in% (cond1$event.id+1)) %>% select(stay.id)
# Test whether the "go" starts and ends at the same location
cond2 <- cond1[stay.before==stay.after,]
View(cond1)
View(cond2)
merge.temporal <- cbind(cond2,stay.before[stay.before==stay.after,])
View(merge.temporal)
# update event summary and gps.traj
event.summary$is.stay[event.summary$event.id %in% merge.temporal$event.id] <- 1
event.summary$stay.id[event.summary$event.id %in% merge.temporal$event.id] <- merge.temporal$stay.id
tally(event.summary,!is.stay)
tally(event.summary,stay.id)
distinct(event.summary,stay.id)
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
merge.temporal <- merge_temporal(event.summary,time.threshold)
# AWEAR: BEHAVIOURAL ANALYSIS FRAMEWORK
#
#********************************************************************************************
# Author: Julia Thorpe
# Written for AWEAR Case Studies, January-June 2018, as part of an ongoing PhD
# project on Engineering Systems Design in Healthcare at DTU in collaboration
# with Rigshospitalet-Glostrup
# This script ...
# SETUP -------------------------------------------------------------------------------------------
# Set the drive, load packages and functions.
#setwd("M:/PhD_Folder/CaseStudies/Data_analysis/source")
## For mobility pack (downloaded from Git) -- maybe don't need these anymore?
#library(DataCombine)
#library(zoo)
#library(plyr)
library(data.table)
library(dtplyr)
library(dplyr)
library(magrittr)
library(lubridate)
library(ggplot2)
library(reshape2)
library(maptools)
library(plotly)
library(maps)
library(mapproj)
library(sp)
library(caTools)
library(geosphere) # added in v3 of data checker
library(mapview) # added in v1 of analysis framework
# Load custom functions:
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/JRT_utils.R")
#source("git_mobility.R")
source("M:/PhD_Folder/CaseStudies/Data_analysis/source/jrt_mobility.R")
# Define constants:
folder <- "M:/PhD_Folder/CaseStudies/Data_dumps/dump_current_analysis/" # path to folder that holds multiple .csv files, downloaded from nightingale webportal
not.in.use <- c("bluetooth","hardware_info","wearable","wifi","calllog","sms")
to_plot <- c("activity", # from data checker, for debugging purposes only (visualise all datasets)
"battery",
"exps",
"location",
"screen",
"steps")
users <- list(julia = "93a6d31c-e216-48d8-a9a2-f2f72362548d",
dean = "b1316280-38a6-45e1-9bb9-7afb2a1a2a96",
per = "7bf5fec3-f46f-419e-9573-001fe9b47d81",
P01FA = "6321f7ef-a958-44ad-b8e5-5aa04bc004e1",
P03JJ = "e9f44eb5-8962-4894-83c6-783025c6eaea")
# SETTINGS -------------------------------------------------------------------------------------------
# Select user and period of interest:
# Test users:
userid <- users$julia
# set the period of interest
d.start <- as.POSIXct("2018-02-05") # yyyy-mm-dd
d.stop <- as.POSIXct("2018-02-19")
# IMPORT AND RESTRUCTURE DATA -------------------------------------------------------------------------------------------
datasets.all <- get.data(folder, not.in.use) %>%
lapply(restructure, userid, d.start, d.stop)
datasets.all <- Filter(function(x) !is.null(x)[1],datasets.all) # remove any null dataframes
remove(d.start, d.stop, folder, not.in.use, userid, users)
# VISUALISE DATA-------------------------------------------------------------------------------------------
#show_plots(datasets.all, to_plot)
# MOBILITY -------------------------------------------------------------------------------------
# References: see files downloaded from GitHub. These use time and distance
# between points against thresholds to assign points to "stay events", based on
# work in an article by Zheng.
# -For each day:
#  .. Number of trips/stays
#  .. Time spent out of / at home
#  .. Distance covered in trajectories
#  .. Plot the day: over time, plot a bar with "home", "transit", "location A", "location B" etc
#  .. Work out how to annotate with the logbooks
# Moblity Setup: create datasets and variables required for mobility calculations -------
# Preprocessing steps
gps.log.pre <- datasets.all$location %>% filter(accuracy<=50) # get rid of data points with an "accuracy" above 50m
keep.ratio <- nrow(gps.log.pre)/nrow(datasets.all$location)
# Get GPS log file
gps.log <- gps.log.pre %>%
select(lat, lon, timestamp, intervals.alt, dates, times) %>%
filter(timestamp>=as.POSIXct("2018-02-13"), timestamp<=as.POSIXct("2018-02-14")) # reduce to single day
# Calculate home coordinates based on location data
home <- find_home(gps.log,"lat","lon")
# STAY DETECTION (to be moved into separate function) ====
##* Initial identification of stays -----
# Define variables:
dT <- 10  # delta T, time window in minutes
dD <- 100 # delta D, distance threshold in meters
gps.traj <- get_stays(gps.log, dT, dD)
# Summarise stay and go events
event.summary <- gps.traj %>% group_by(event.id) %>%
summarize(T.start = min(timestamp), is.stay = max(is.stay)) %>%
mutate(T.end = c(T.start[-1],max(gps.traj$timestamp))) %>%
mutate(durations = difftime(T.end,T.start, units = "mins"))
## ________________________________________
##* Merge spatially close stays -----
# define variables:
dist.threshold <- 30 # distance in meters within which two centriods belong to same stay location
# Calculate centroids of all stay events
stay.centroids <- gps.traj %>% filter(is.stay==1) %>% group_by(event.id) %>%
summarize(lat = mean(lat, na.rm=TRUE), lon = mean(lon, na.rm = TRUE))
# Get groups of stays belongs to same location, and assign ID's to each stay location
merges <- merge_spatial(stay.centroids,dist.threshold)
event.summary %<>% mutate(stay.id = ifelse(is.stay,event.id,NA))
for (m in merges){
print(m)
event.summary[(event.summary$event.id %in% m),"stay.id"] <- m[[1]]
}
## ________________________________________
##* Merge temporaly close stays -----
# Eliminate "go" events if:
# (1) they start and end at same location, AND
# (2) are less than 5 minutes
time.threshold <- 5 # in minutes
merge.temporal <- merge_temporal(event.summary,time.threshold)
# update event summary and gps.traj
event.summary$is.stay[event.summary$event.id %in% merge.temporal$event.id] <- 1
event.summary$stay.id[event.summary$event.id %in% merge.temporal$event.id] <- merge.temporal$stay.id
